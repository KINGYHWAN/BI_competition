{"cells":[{"cell_type":"markdown","metadata":{"id":"l4di995E3H_R"},"source":["# importing, API Key"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":8502,"status":"ok","timestamp":1687165501480,"user":{"displayName":"정민균","userId":"02008085652330605669"},"user_tz":-540},"id":"EmCNj0yNNNyB","outputId":"bd9ee7c3-2cb3-4406-843d-cf7532ea1911"},"outputs":[{"output_type":"stream","name":"stdout","text":["Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"akMgGWD-hy56"},"outputs":[],"source":["# 모듈 import\n","import requests\n","import pprint\n","import bs4\n","from lxml import html\n","from urllib.parse import urlencode, quote_plus, unquote\n","import pandas as pd\n","\n","# 인증키는 파라미터로 사용할거라서 encoding 이나 decoding에 저장해놓기\n","\n","    # 아래 인증키는 예시로 실제로는 존재하지 않는 값으로 바꿔 놓은거에요 실제로 하려면 API Key 발급 받으세용\n","\n","# 인증키 입력\n","encoding = 'krXiIV2saGLs2q0y37QxMoocEgXWyj53g8a%2F1XlpuLMgpEhzE5BkI8N9ogyg4ykq4W5FvysQsUOY8wQ%3D%3D'\n","decoding = 'krXisaGLs2q0y37QxvGMoocEgXWyj53g8a/1XlgpEhzEt15BkI8N9ogyg4ykq4tXWW5FvyOY8wQ=='"]},{"cell_type":"markdown","metadata":{"id":"dcq2qYlY4RzA"},"source":["# 함수 구동 전 사전작업\n","\n","- API 입력용 날짜리스트 date_list 리스트에 저장\n","\n","- 지역정보 ID 딕셔너리에 저장 (지역명 : 지역코드, format용 영문명)"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":4,"status":"ok","timestamp":1687210283588,"user":{"displayName":"정민균","userId":"02008085652330605669"},"user_tz":-540},"id":"x8RGZDtnpjb0","outputId":"5dc96fb1-8ca5-4b83-aca6-384ae45dd6ee"},"outputs":[{"output_type":"stream","name":"stdout","text":["['20120101', '20120211', '20120323', '20120503', '20120613', '20120724', '20120903', '20121014', '20121124', '20130104', '20130214', '20130327', '20130507', '20130617', '20130728', '20130907', '20131018', '20131128', '20140108', '20140218', '20140331', '20140511', '20140621', '20140801', '20140911', '20141022', '20141202', '20150112', '20150222', '20150404', '20150515', '20150625', '20150805', '20150915', '20151026', '20151206', '20160116', '20160226', '20160407', '20160518', '20160628', '20160808', '20160918', '20161029', '20161209', '20170119', '20170301', '20170411', '20170522', '20170702', '20170812', '20170922', '20171102', '20171213', '20180123', '20180305', '20180415', '20180526', '20180706', '20180816', '20180926', '20181106', '20181217', '20190127', '20190309', '20190419', '20190530', '20190710', '20190820', '20190930', '20191110', '20191221', '20200131', '20200312', '20200422', '20200602', '20200713', '20200823', '20201003', '20201113', '20201224', '20210203', '20210316', '20210426', '20210606', '20210717', '20210827', '20211007', '20211117', '20211228', '20220207', '20220320', '20220430', '20220610', '20220721', '20220831', '20221011', '20221121', '20230101', '20230211', '20230324']\n","101\n"]}],"source":["# 이후에 for문 돌릴때 사용할 날짜 리스트 만들기\n","\n","from datetime import datetime, timedelta\n","\n","start_date = datetime.strptime(\"2012-01-01\", \"%Y-%m-%d\")\n","end_date = datetime.strptime(\"2023-03-29\", \"%Y-%m-%d\")\n","\n","date_list = []\n","current_date = start_date\n","\n","while current_date <= end_date:\n","    date_list.append(current_date.strftime(\"%Y%m%d\"))\n","    # 41일 씩 끊어서 만들었음, 이유는 뒤에 나옵니다\n","    current_date += timedelta(days=41)\n","\n","# 만들어진 리스트, 길이 확인\n","print(date_list)\n","print(len(date_list))"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bB5io08F33C6"},"outputs":[],"source":["# 딕셔너리에 key : '지역명' value = [지역별 검색 번호, '지역 영문명'] 으로 저장,\n","# API 호출 함수에서 '지역명' 입력하면 자동으로 지역 검색번호 입력하고, 나중에 파일 저장 시 '영문명_df' 로 저장하기위해 만들어 놓음\n","\n","ID={\n","  # 특별, 광역 시\n","    '서울' : [108, 'seoul'], '부산' : [159, 'busan'], '대구' : [143, 'daegu'], '인천' : [112, 'incheon'],\n","    '광주' : [156, 'gwangju'], '대전' : [133, 'daejeon'], '울산' : [152, 'woolsan'], '세종' : [239, 'saejong'],\n","  # 경기도 지역은 뒤에 _Gg\n","    '수원' : [119, 'suwon_Gg'], '파주' : [99, 'paju_Gg'], '양평' : [202, 'yangpyeong_Gg'], '동두천' : [98, 'dongducheon_Gg'],\n","  # 강원도 지역은 뒤에 _Gw\n","    '태백' : [216, 'taebaek_Gw'], '원주' : [114, 'wonju_Gw'], '철원' : [95, 'cheolwon_Gw'], '속초' : [90, 'sokcho_Gw'],\n","  # 충청도 지역은 뒤에 _Cc\n","    '서산' : [129, 'seosan_Cc'], '부여' : [236, 'buyeo_Cc'], '금산' : [238, 'geumsan_Cc'], '제천' : [221, 'jecheon_Cc'],\n","  # 전라도 지역은 뒤에 _Jl\n","    '여수' : [168, 'yeosu_Jl'], '해남' : [261, 'haenam_Jl'], '군산' : [140, 'gunsan_Jl'], '장수' : [248, 'jangsu_Jl'],\n","  # 경상도 지역은 뒤에 _Ks\n","    '울진' : [130, 'wooljin_Ks'], '상주' : [137, 'sangju_Ks'], '남해' : [295, 'namhae_Ks'], '김해' : [253, 'gimhae_Ks'],\n","  # 제주도 지역은 뒤에 _Jj\n","    '제주' : [184, 'jeju_Jj'], '서귀포' : [189, 'seoguipo_Jj'],\n","  # 프로젝트 중간에 추가 수집 하기로 한 지역이라 뒤에 _도명 이름이 위에랑 다름\n","    '경주' : [283, 'gyeongju_KB'], '구미' : [279, 'gumi_KB'], '거창' : [284, 'geochang_KN'], '밀양' : [288, 'milyang_KN'],\n","    '영광' : [252, 'yeonggwang_JN'], '순천' : [174, 'sooncheon_JN'], '남원' : [247, 'namwon_JB'], '고창' : [251, 'gochang_JB'],\n","    '천안' : [232, 'cheonahn_CN'], '보은' : [226, 'boeun_CB'], '청주' : [131, 'cheongju_CB']\n","}"]},{"cell_type":"markdown","metadata":{"id":"RhImMmz-2Lsq"},"source":["# API 가져오는 함수 만들기\n","\n","- 날짜, 지역을 함수에 넣어 for 문 돌릴 예정임\n","\n","- whtdata 에서 41일 치 dataframe 가져오고,\n","- make_df 라는 함수로 전체 기간 합쳐서 dataframe 만들고, 드라이브에 저장"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"AY8n5Qeeh0yf"},"outputs":[],"source":["# 지역, 시작일, 끝일을 입력하면 받아지도록 함수 설정\n","def whtdata(stNm, date, start):\n","  global ID\n","  # API 가져오는 기본 URL 중간중간 {} 에는 특정 파라미터를 입력해야함\n","  base_url = 'http://apis.data.go.kr/1360000/AsosHourlyInfoService/getWthrDataList?serviceKey={serviceKey}&numOfRows={numOfRows}&pageNo={pageNo}&dataCd={dataCd}&dateCd={dateCd}&stnIds={stnIds}&endDt={endDt}&endHh={endHh}&startHh={startHh}&startDt={startDt}'\n","\n","  # 입력해야할 파라미터 들 입력\n","  params = {\n","      \"serviceKey\": encoding,\n","      \"numOfRows\": date,# 한번에 가져올 날짜 정보 개수는 1000개를 넘어갈 수 없음, 그래서 984개(41일치) 입력했음 중간중간\n","      \"pageNo\": '1',\n","      \"dataCd\": \"ASOS\",\n","      \"dateCd\": \"HR\", # 시간단위\n","      \"stnIds\": ID[stNm][0], # 지역 번호\n","      \"endDt\": '20230331', # 끝날짜\n","      \"endHh\": \"01\", # 끝 시간대\n","      \"startHh\": \"00\", # 시작시간대\n","      \"startDt\": start # 시작 날짜\n","  }\n","  # formatting으로 url 정하기, (함수 변수 넣기)\n","  url = base_url.format(**params)\n","\n","  # url에서 정보 가져오기\n","  response = requests.get(url)\n","\n","  # 가져온 정보에서 xml 추출, 갖고싶은 기상정보들은 item에 있음\n","  content = response.text\n","  xml_obj = bs4.BeautifulSoup(content,'lxml-xml')\n","  te = xml_obj.find_all('item')\n","  datas = [] # 담아놓을 2차원 리스트\n","\n","  # te 정보 리스트에 몽땅 담기\n","    # 이때 if, else로 서버의 순간 오류로 빈 값이 오게 될때 for문이 멈추지 않도록 함\n","    # 데이터 양이 너무 방대해 서버가 순간 끊기는 경우가 반드시 발생함 (이렇게 빈 값이 오는 경우는 나중에 채워준다)\n","  for i in range(len(te)):\n","      tm = te[i].tm.string.strip() if te[i].tm and te[i].tm.string else \"\"\n","      stnNm = te[i].stnNm.string.strip() if te[i].stnNm and te[i].stnNm.string else \"\"\n","      ta = te[i].ta.string.strip() if te[i].ta and te[i].ta.string else \"\"\n","      rn = te[i].rn.string.strip() if te[i].rn and te[i].rn.string else \"\"\n","      hm = te[i].hm.string.strip() if te[i].hm and te[i].hm.string else \"\"\n","      ss = te[i].ss.string.strip() if te[i].ss and te[i].ss.string else \"\"\n","      icsr = te[i].icsr.string.strip() if te[i].icsr and te[i].icsr.string else \"\"\n","      dsnw = te[i].dsnw.string.strip() if te[i].dsnw and te[i].dsnw.string else \"\"\n","\n","      data = [tm, stnNm, ta, rn, hm, ss, icsr, dsnw]\n","      # 2차원 리스트에 저장\n","      datas.append(data)\n","\n","  # 2차원 리스트 쌓아 놓은 것 ex_df로 데이터프레임화\n","  ex_df=pd.DataFrame(datas, columns=['시간','지역명','기온','강수량','습도','일조','일사','적설'])\n","\n","  return ex_df\n","\n","# 원래 이 API에서 가져올 수있는 모든 기상정보 변수는 아래와 같음\n","# data = [tm, stnId, stnNm, ta, taQcflg, rn, rnQcflg, ws, wsQcflg, wd, wdQcflg, hm, hmQcflg, pv, td, pa, paQcflg, ps,\n","#         psQcflg, ss, ssQcflg, icsr, dsnw, hr3Fhsc, dc10Tca, dc10LmcsCa, clfmAbbrCd, lcsCh, vs, gndSttCd, dmstMtphNo, ts, tsQcflg,\n","#         m005Te, m01Te, m02Te, m03Te]"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"JWbogDpi8NQ4"},"outputs":[],"source":["# 데이터프레임 제작 함수 make_df\n","def make_df(stNm):\n","  ndf=pd.DataFrame()\n","  #초기값 만들어 놓고 그 다음부터 진행 (쌓아가니까))\n","  # for _ in range(len(date_list)):\n","  for _ in range(len(date_list)-1):\n","    # 지역명, 984일, 위에서 41일씩 끊어서 저장한 리스트 를 입력해 whtdata 함수로 데이터프레임 가져오면 df에 저장\n","    df=whtdata(stNm,984, date_list[_])\n","\n","    # 생성될때마다 이어 붙이기\n","    ndf=pd.concat([ndf,df], axis=0)\n","\n","  # date_list 확인하면 23년03월 24일이 마지막인데 이때부터 목표날짜인 03 30일 까지 7일으로 168개가 필요함, 근데 나중에 interpolation용으로 하나 더 넣어주기\n","    # 그래서 24*7+1 = 169로 날짜 수 설정\n","  ndf=pd.concat([ndf,whtdata(stNm,169, date_list[-1])], axis=0)\n","  ndf=ndf.reset_index(drop=True)\n","\n","  # 그렇게 종합이 완료된 ndf는 저장경로명, 파일 이름 지정해 드라이브에 저장\n","    # ex) seoul.df 등\n","  ndf.to_csv('/content/drive/MyDrive/2023 겨울학기 + 여름학기/B.I Contest/데이터/지역별 기상데이터 모음/1차 수집/{}_df.csv'.format(ID[stNm][1]), index=False)\n","\n","  # globals 하면 함수에서 return으로 저장받지 않아도 변수가 현재 런타임에 저장이 됨\n","  globals()['{}_df'.format(ID[stNm][1])]=ndf\n","\n","  # 저장은 자동으로 하고 df 크기만 확인 (instance가 누락된 값이 있는지 확인할 필요가 있어서))\n","  return ndf.shape"]},{"cell_type":"markdown","metadata":{"id":"HlsSl_ZzK3nI"},"source":["# 데이터프레임 저장하기\n","\n","- State_Name속 값을 make_df()에 넣으면 됨\n","            State_Name=['서울','부산','대구','인천','대전','울산','세종','광주','수원','파주',\n","            '양평','동두천','태백','원주','철원','속초','서산','부여','금산','제천',\n","            '여수','해남','군산','장수','울진','상주','남해','김해','제주','서귀포',\n","            '경주','구미','거창','밀양','영광','순천','남원','고창','천안','보은','청주']\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"JbUiyZcWHbX0"},"outputs":[],"source":["# 혹시 for문을 돌릴 수도 있으니 State_Name을 전부 넣어 놓았습니다\n","\n","# 한번에 30개 지역을 돌리는건 빡세서 나눠서 돌리다보니, State_Name, completed 등에 돌아간건 수동으로 업데이트 했음\n","\n","\n","State_Name=['경주','구미','거창','밀양','영광','순천','남원','고창','천안','보은','청주']\n","\n","completed=['서울','인천','광주','대구','부산','대전','울산','세종',\n","           '수원','파주','양평','동두천',\n","           '태백','원주','철원','속초',\n","           '서산','부여','금산','제천',\n","           '여수','해남','군산','장수',\n","           '울진','상주','남해','김해',\n","           '제주','서귀포']"]},{"cell_type":"code","source":["# 이미 수집된 녀석들 확인하고 90000개 미만의 요소가 모인 녀석들의 리스트를 다시 수집 하려고 했었음\n","# 90000개 미만이면 다시 수집하는게 더 경제적이라고 생각했는데 이후에 함수를 다시짜서 해결함 그래서 아래 코드는 실제로는 안썼다고 할 수 있음\n","\n","# 90000개 미만이면 recomp에 저장하고, 이상이면 result에 저장\n","recomp=[]\n","result=[]\n","\n","for _ in State_Name:\n","  df=pd.read_csv('/content/drive/MyDrive/2023 겨울학기 + 여름학기/B.I Contest/데이터/지역별 기상데이터 모음/1차 수집/{}_df.csv'.format(ID[_][1]))\n","  print('{}의 크기 :'.format(ID[_][1]), df.shape)\n","  # print('수집이 안된 날의 수? :', float((98545-df.shape[0])/960), '\\n')\n","  if df.shape[0] <= 90000:\n","    recomp.append(_)\n","  else:\n","    result.append(_)\n","\n","# 전부 다 돌린다음에 수집 된거, 수집안된거 보여지도록 구성\n","print(\"수집이 완료되지 않은 지역 목록 :\",recomp)\n","print(\"다시 수집해야하는 df 개수 :\", len(recomp),'\\n')\n","print('수집이 완료된 지역 목록 :', result)\n","\n","# State_Name 등을 계속 바꿔가며 하다보니 출력 결과가 좀 왔다갔다 한다."],"metadata":{"id":"uGaPHAMQm60a","executionInfo":{"status":"ok","timestamp":1687213725133,"user_tz":-540,"elapsed":5937,"user":{"displayName":"정민균","userId":"02008085652330605669"}},"colab":{"base_uri":"https://localhost:8080/"},"outputId":"0a417ce3-7f92-4bb3-c09e-075087a77362"},"execution_count":null,"outputs":[{"output_type":"stream","name":"stdout","text":["gyeongju_KB의 크기 : (91681, 8)\n","gumi_KB의 크기 : (83809, 8)\n","geochang_KN의 크기 : (92665, 8)\n","milyang_KN의 크기 : (95617, 8)\n","yeonggwang_JN의 크기 : (90697, 8)\n","sooncheon_JN의 크기 : (95617, 8)\n","namwon_JB의 크기 : (91681, 8)\n","gochang_JB의 크기 : (91681, 8)\n","cheonahn_CN의 크기 : (90697, 8)\n","boeun_CB의 크기 : (86761, 8)\n","cheongju_CB의 크기 : (87745, 8)\n","수집이 완료되지 않은 지역 목록 : ['구미', '보은', '청주']\n","다시 수집해야하는 df 개수 : 3 \n","\n","수집이 완료된 지역 목록 : ['경주', '거창', '밀양', '영광', '순천', '남원', '고창', '천안']\n"]}]},{"cell_type":"code","source":[],"metadata":{"id":"Rtebk03E5A-P"},"execution_count":null,"outputs":[]}],"metadata":{"colab":{"provenance":[],"collapsed_sections":["l4di995E3H_R","dcq2qYlY4RzA","RhImMmz-2Lsq","HlsSl_ZzK3nI"],"mount_file_id":"1MxwPUjLMwVMAwO4_OE1El1LeovzKkdU8","authorship_tag":"ABX9TyPM8dIY/ElNi2EtT733Zft3"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}